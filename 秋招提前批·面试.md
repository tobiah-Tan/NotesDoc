# 秋招/提前批·面试

## 一、HTTP请求报文/响应报文

### 1、HTTP协议

#### 1.1、 简介

- HTTP协议又称超文本传输协议(Hyper Text Transfer Protocol)，用于万维网服务器传输超文本到本地浏览器的传送协议

- HTTP基于TCP/IP通信协议来传递数据

- HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议

#### 1.2 、特点

- HTTP是无连接的：无连接的含义就是现实每次链接之处理一个请求，服务器处理完客户的请求，并受到客户的应答后，即断开链接，采用这种方式可以节省传输时间
- HTTP是媒体独立的，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的MIME-type内容类型。
  - MIME-type：是资源的媒体类型，通过HTTP协议，由web服务器告知浏览器，更准确的说，是通过Content-Type来表示的，例如`Content-Type:text/HTML`
  - MIME-type不是个人指定的，是由ietf组织协商，以RFC的形式作为建议的标准发布在网上的，大多数web服务器和用户代理都会支持这个规范。
- HTTP是无状态的：无状态是之协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次链接传送的数据量增大，另一方面，再服务器不需要先前信息时他的应答就比较快。

#### 1.3、  构成

HTTP请求报文由三个部分组成：

- 请求行
- 请求头
- 请求体

##### 1.3.1  请求行

- 请求方法：GET/POST时最常见的HTTP请求方法，除此之外还包括DELETE、HEAD、OPTIONS、PUT、TRACE
- 为请求对应的url地址，他的报文头的Host属性组成完成的请求URL
- 协议名称以及版本号

##### 1.3.2 请求头

- HTTP的报文头，报文头包含若干个属性，格式为“属性名：属性值”，服务端据此获取客户端的信息。
- 与缓存相关的规则信息，均包含在header中

##### 1.3.3 请求体

- 报文体，将一个页面表单中的组件值通过`param1=value1&param2=value2`的键值对形式编码成一个格式化串，它承载多个请求参数的数据，不但报文体可以传递请求参数，请求URL也可以通过类似于`/chapter15/user.html? param1=value1&param2=value2`的方式传递请求参数

### 2、HTTP请求报文头属性

#### 2.1、 Accept

通过Accept报文头属性告诉服务器，客户端接收什么类型的响应。

Accept属性的值可以为一个或多个MIME类型的值

#### 2.2、 Cookie

##### 2.2.1 客户端的Cookie就是通过这个报文头属性传给服务端的

`Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23`

- 原因：HTTP协议是无状态协议(不保存状态，即不保留之前的一切请求或相应信息)，为了提高效率，希望保持状态功能，引入cookie技术
- Cookie：就是一段字符串，是浏览器保存服务器返回数据的方法，通常保存用户身份信息
- Set-Cookie：服务器向浏览器中种下cookie，当浏览器访问符合条件的url，就会自动带上这个cookie

##### 2.2.2 服务流程

- 客户端第一次请求时，如果服务器像保存用户信息，服务器向客户端响应时会带有set-cookie字段
- 客户端会保存cookie，在下次请求时会自动带上cookie
- 这样服务器收到cookie后，就知道是哪个客户端发来的请求，得到之前的状态信息

Cookie的maxAge决定着Cookie的有效期，单位为秒，Cookie中通过getMaxAge()方法与setMaxAge()方法来读写maxAge属性

- 如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效
- 如果maxAge为负数，则表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie失效
- 如果maxAge为0，则表示删除该Cookie

Cookie并不提供修改、删除操作，如果要修改某个Cookie，只需要新建一个同名Cookie，添加到response中覆盖原来的Cookie

如果想要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie

```javascript
Cookie cookie = new Cookie("username","helloweenvsfei");//新建cookie
cookie.setMaxAge(0);//设置生命周期为0，不能为负数
response.addCookie(cookie);//必须执行这一句，输出到客户端
```

#### 2.3、Referer

表示这个请求是从哪个URL过来的，假如你通过Google搜索出一个商家的广告界面，你对这个广告页面感兴趣，鼠标点击发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值就是`http:www.google.com`

#### 2.4 Cache-Control

对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的

### 3、HTTP响应报文

#### 3.1、 响应报文

HTTP的响应报文也有三部分组成（响应行+响应头+响应体）

- 响应行：
  - 报文协议及版本
  - 状态码及状态描述
- 响应头：
  - 响应报文头，也是由多个属性组成
- 响应体：
  - 响应报文体，即我们真正需要的信息干货

#### 3.2、 响应状态码

响应报文多了一个响应状态码，告诉客户端本次请求的处理结果

HTTP的响应状态码由5段组成:

```
1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急...
2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.
3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。
4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。
5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。
```

```
100	Continue	继续。客户端应继续其请求
101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
200	OK	请求成功。一般用于GET与POST请求
201	Created	已创建。成功请求并创建了新的资源
202	Accepted	已接受。已经接受请求，但未处理完成
203	Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
205	Reset Content	重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
206	Partial Content	部分内容。服务器成功处理了部分GET请求
300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI   						代替
302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
303	See Other	查看其它地址。与301类似。使用GET和POST请求查看
304	Not Modified   未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望 					只返回在指定日期之后修改的资源
305	Use Proxy	使用代理。所请求的资源必须通过代理访问
306	Unused	已经被废弃的HTTP状态码
307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向
400	Bad Request	客户端请求的语法错误，服务器无法理解
401	Unauthorized	请求要求用户的身份认证
402	Payment Required	保留，将来使用
403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
405	Method Not Allowed	客户端请求中的方法被禁止
406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求
407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
408	Request Time-out	服务器等待客户端发送的请求时间过长，超时
409	Conflict	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突
410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息
412	Precondition Failed	客户端请求信息的先决条件错误
413	Request Entity Too Large   由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无								法处理，则会包含一个Retry-After的响应信息
414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理
415	Unsupported Media Type	服务器无法处理请求附带的媒体格式
416	Requested range not satisfiable	客户端请求的范围无效
417	Expectation Failed	服务器无法满足Expect的请求头信息
500	Internal Server Error	服务器内部错误，无法完成请求
501	Not Implemented	服务器不支持请求的功能，无法完成请求
502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求
505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理
```



#### 3.3、 常见的HTTP响应报文头属性

##### 3.3.1 cache-control

- 响应输出到客户端后，服务端通过该报文头属性告诉客户端如何控制相应内容的缓存
- 常见的取值有private、public、no-cache、max-age、no-store，**默认为private**
  - private：客户端可以缓存
  - public：客户端和代理服务器都可以缓存
  - max-age = xxx：缓存的内容将在 xxx 秒以后失效
  - no-cache：需要使用xxx来验证缓存数据，所有内容都不会缓存

##### 3.3.2 ETag

一个代表响应服务器资源版本的报文头属性，如果某个服务端自愿发生变化了，这个ETag就会相应发生变化。他是Cache-Control的有益补充，可以让客户端“更智能”处理什么时候要从服务器取资源，什么时候可以直接从换成那种返回响应

##### 3.3.3 Location

我们在JSP(JavaServer Page)中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect的baidu的首页中

```
Location:http://www.baidu.com
```

##### 3.3.4 Set-Cookie

服务端可以设置客户端的Cookie，原理就是通过这个响应报文头的属性实现的：

```
Set-Cookie:UserID=JohnDoe;Max-Age=3600;Version=1
```

## 二、浏览器渲染过程

### 2.1 渲染主流程

- 浏览器将获取的HTML文档解析成DOM树
- 处理CSS标记，构成层叠样式表模型（CSS Object Module）
- 将DOM和CSSOM合并为渲染树(render树)，将会被创建，代表一系列即将被渲染的对象
- 渲染树的每个元素内容都是计算过的，它被称之为布局(layout)，浏览器使用一种流式处理的方法，只需要一次pass绘制就可以布局所有元素，浏览器通过render树就可以确定各个节点的css定义以及他的从属关系，从而计算出每个节点在屏幕中的位置
- 将渲染树的各个节点，绘制到屏幕上，这一步称之为painting，按照计算出来的内容，通过显卡，显示到屏幕上
- reflow（回流）：若浏览器发现某个节点发生变化影响布局，需要倒回去重新渲染称之为reflow

### 2.2、细化流程

- 构建DOM树
  - 收到HTML文档后，便利文档节点生成DOM树，DOM树结构和HTML标签一一对应
  - 注意：
    - DOM树在构建过程中可能会被CSS和JS的加载而执行阻塞
    - `display:none`元素也会在DOM树中
    - 注释也会在DOM树中
    - script标签会在DOM树中
- CSS解析
  - 浏览器会解析CSS文件并生成CSS规则树，每个CSS文件都会被分析成styleSheet对象，每个对象都包括CSS规则，CSS规则对象包括对应的的选择器和声明对象及其他对象
  - 注意：
    - CSS解析可以与DOM解析同时进行
    - CSS解析与script的执行互斥

## 三、GET/POST 区别

### 3.1、直观

- GET是把参数包含在URL中
- POST是通过request body传递参数

### 3.2、详细

- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET产生的URL地址可以被Bookmark，而POST不可以
- GET请求会被浏览器主动cache，而POST不会，除非手动设置
- GET请求只能进行url编码，而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
- GET请求在URL中传送的参数是有长度限制的，而POST没有
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- GET比POST更不安全，因为参数会直接暴露在URL上，不能用来传递敏感信息
- GET参数通过URL传递，POST放在Request body中

### 3.3、本质

- 都是HTTP协议中的两种发送请求的方法，而HTTP底层就是TCP/IP，所以GET和POST底层也是TCP/IP，都是TCP链接，所以在GET加上request body，给POST带上url参数从技术层面上是行得通的
- 不同浏览器（发送http请求）和服务器（接收http请求），理论上url中无限制参数大小，但是由于数据量太大会对浏览器和服务器造成很大负担，不成文规定，浏览器通常会限制url长度在2k字节，而大多数服务器最多处理64K大小的url，超过的部分选择不处理。如果用GET服务，在request body中藏了数据，不同服务器的处理方式也是不同的，有的会读出数据，有的就会直接忽略，所以GET是可以带request body但是不保证会收到。

### 3.4、冷知识

GET和POST还有一个相对冷门的重大区别

- GET会产生一个数据包
- POST会产生两个数据包

GET方式的请求，浏览器会把http header 和 data 一并发送出去，服务器响应200（返回数据），而POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

比喻来讲，GET只需跑一趟就可以把货送到，而POST需要跑两趟，第一趟是先去和服务器打个招呼，第二趟再回头把货送过去

因为POST需要两部，时间上消耗的要多一点，看起来GET和POST更高效，但是不能就用GET全部替代POST，原因有下：

- GET和POST都有自己的语义，不能随便混用
- 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的的优点。
- 并不是所有浏览器都会在POST中发送两次包，Firefox就只会发送一次


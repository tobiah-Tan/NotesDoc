# JavaScriptNotes

ECMAScript - JavaScript标准

DOM - 文档对象模型

BOM - 浏览器对象模型

## 一、 js 的编写位置

- 可以将js代码编写到标签的 onclick 属性中

  - 当我们点击按钮时，js代码才会执行
  - 可以将js代码写在超链接的href属性中，点击超链接时，js代码执行

  ```javascript
  <a href="javascript:alart('弹框');">点击</a>
  ```

  虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用

  - 可以将js代码编写到script标签里
  - 可以将js代码编写到外部js文件中，然后通过script标签引入
    - 写到外部文件中可以在不同的页面中同时引用，也可以利用浏览器的缓存机制，这是推荐使用的方式

  ```javascript
  <script type="text/javascript" src="js/script.js"></script>
  ```

  - script标签一旦用于引入外部文件了，就不能再编写代码了，即使编写浏览器也会自动忽略，如果有需要，则可以再创建一个新的script标签
  
- 最好的方法是将script标签的js代码放到HTML文档的最后，也就是\</body>之前

  - 这样做的目的是便于提高浏览器加载页面的效率

## 二、 基本语法

### 1. 注释

多行注释 

单行注释

```javascript
/* */
//
```

可以通过注释对代码进行简单的调试

### 2. 格式

- js中严格区分大小写
- js中每一条语句都要以分号(;)结尾
  - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，而且有些时候浏览器会加错分号
- js中会忽略多个空格和换行，所以可以利用空格和换行对代码进行格式化，使代码美观

### 3. 字面量和变量

- 字面量：都是一些不可改变的值

  比如：1，2，3，4，5

  - 字面量都是可以直接使用的，但是我们一般都不会直接使用字面量

- 变量：变量可以用来保存字面量，而且变量的值使可以任意改变的

  - 变量更加便于我们使用，所以在开发中是通过变量来保存一个字面量

- 变量声明

  - 在js中 使用var关键字来声明一个变量
- 注意：函数体内部如果不用var定义变量，则变量是全局变量，易造成内存泄露
  
  ```javascript
  var a;
  a = 123;
  console.log(a);
  ```

### 4. 标识符

- 在js中所有的可以由我们自主命名的都可以称为是标识符
- 命名一个标识符时需要遵守如下的规则：
  - 标识符中可以含有字母、数字、下划线_、$
  - 标识符不能以数字开头
  - 标识符不能是es中的关键字或者博保留字
  - 标识符一般都采用驼峰命名法
    - 首字母小写，每个单词开头字母大写，其余字母小写
  - js底层保存的标识符实际上是采用了Unicode编码
    - 所以理论上来讲，所有的utf-8中含有的内容都可以作为标识符

## 三、 数据类型

- 数据类型指的是字面量的类型

  - 在js中有六种数据类型

    - String 字符串
    - Number 数值

    - Boolean 布尔值
    - Null 空值
    - Undefined 未定义
    - Object 对象

  - 其中 String Number Boolean Null Undefined 属于基本数据类型

  - Object 属于引用数据类型

### 1. String 字符串

- 在js中字符串需要使用引号引起来

- 使用双引号和单引号都可以，但是不要混着用

- 引号不能嵌套，双引号不能放双引号，单引号不能放单引号

- 在字符串中我们使用\作为转义字符

  - 当表示一些特殊符号时可以使用\进行转义

  ```javascript
  \" 表示 "
  \' 表示 '
  \n 表示换行
  \t 表示制表符
  ```

### 2. Number 数值

- 在js中所有的数值都是Number类型
  - 包括整数和浮点数
- 可以使用一个运算符 typeof 来检查一个变量的类型
- js中可以表示的数字的最大值
  - Number.MAX_VALUE
  - 如果使用Number表示的数字超过了最大值，则会返回一个infinity(表示无穷大)
  - NaN 是一个特殊的数字，表示 not a number 
- 如果使用js进行浮点数元素，可能得到一个不精确的结果
  - 所以不要使用js进行精确度要求比较高的运算

### 3. Boolean 布尔型

- 布尔值有两个，true false 
- 用来做逻辑判断

### 4. Null

- Null类型的值只有一个，就是null

- null专门用来表示一个为空的对象

### 5. Undefined 

- 值只有一个就是undefined
  - 当我们声明一个变量，但是并不给他赋值时，就是undefined

### 6. 强制类型转换

- 指将一个数据类型强制转换成其他的数据类型
- toString()
  
  - null和undefined 这两个值没有toString()方法，如果调用可能会报错
- String() 函数
  - 将被转换的数据作为参数传递给函数
  - 使用String()函数强制类型转换时，对于Number和Boolean，底层就是调用toString()
  - 但是对于null和undefined 不会调用tostring()，会将null直接转换成"null"

- parseInt() 把一个字符串转换成一个整数

  - parseInt() 可以将一个字符串中的有效的**整数**内容取出来

- parseFloat() 把一个字符串转换为一个浮点数

  - 与parseInt() 类似，不同的是它可以获得有效的小数

- 如果对非String 使用parseInt() 或 parseFloat() 他会将其转换为String然后再操作

- 将其他类型数据转换为Boolean

  - 使用Boolean() 函数

    除了 0 和NaN 其余数字都是true

    字符串转Boolean，除了空串其余都是true

    null和undefined 都是false

    对象也会转换为true

### 7. 算数运算符

- 如果对两个字符串做加法运算，则会做拼接
- 任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
  - 可以利用这一点为任意的数据类型 + 一个“”(空串)，即可将其转换为String
  - 这是一种隐式的类型转换，由浏览器自动完成，实际上就是调用了String()方法

### 8. 一元运算符

- 对于非Number类型的值
  - 它会将先转换为Number，然后再运算
  - 可以对一个其他的数据类型使用 + ，来将其转换为number类型
  - 原理和Number() 一样

## 四、 对象Object

### 1. 对象的分类

- 内建对象
  - 由es标准中定义的对象，在任何的es的实现中都可以使用
- 宿主对象
  - 由js的运行环境提供的对象，目前来讲主要是指由浏览器提供的对象
  - 比如 BOM DOM
- 自定义对象
  - 由开发人员自己创建的对象

### 2. 创建对象

- 使用new关键字调用的函数，是构造函数constructor
- 构造函数时专门用来创建对象的函数
- 使用typeof检查一个对象时，会返回object

### 3. 属性和属性值

- 在对象中保存的值称为属性

- 向对象中添加属性

  - 语法： 对象.属性名 = 属性值;

- 读取对象中的属性

  - 语法： 对象.属性名
  - 如果读取对象中没有的属性，不会报错而是返回undefined

- 删除对象中的属性

  - delete 对象.属性

- 向对象中添加属性

  - 属性名：

    - 对象的属性名不强制要求遵守标识符的规范
    - 但是我们使用还是尽量按照标识符的规范去做

  - 如果使用特殊的属性名，不能采用.的方式来操作

    - 需要使用另一种方式：

      语法： 对象["属性名"] = 属性值

      读取时也需要采用这种方式

    - 使用[]这种形式操作属性，更加灵活

      在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性

  - 属性值

    - js对象的属性值，可以是任意的数据类型

- in 运算符

  - 通过该运算符可以检查一个对象中是否含有指定的属性
  - 语法： “属性名“ in 对象

### 4. 基本数据类型和引用数据类型

- js的变量都是保存在栈内存中的

  - 基本数据类型的值都是最直接在栈内存中存储
    - 值与值之间是独立存在，修改一个变量不会影响其他变量
  - 对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址(对象的引用)，如果两个变量博爱村的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响
  - 当比较两个基本数据类型的值时，就是比较值大小
  - 比较两个引用数据类型时，就是比较对象的内存地址
    - 如果两个对象是一模一样的，但是地址不同，则会返回false

- 适用对象字面量创建一个对象

  - 使用对象字面量，可以在创建对象时，直接指定对象中的属性
    - 语法：{属性名：属性值 , 属性名：属性值，... }
  - 对象字面量的属性名可以加引号，也可以不加，建议不加
  - 属性名和属性值是一组一组的名值对结构
    - 名和值之间使用:连接，多个名值对之间使用,隔开
    - 如果一个属性之后没有其他的属性了，就不用些,了

  ```javascript
  var obj = {name:"猪八戒"};
  ```

### 5. 函数

- 函数（Function）也是一个对象

  - 函数中可以封装一些功能(代码)，在需要时可以执行这些功能
  - 函数可以保存一些代码在需要时调用、
  - 使用typeof检查一个函数对象时，会返回function

- 创建一个函数对象

  - 可以将要封装的代码以字符串的形式传递给构造函数

  ```javascript
  var fun = new Function("console.log('hello world!')");
  fun();
  ```

  - 封装到函数中的代码不会立即执行
  - 函数中的代码会在函数调用的时候执行
  - 调用函数 语法：函数对象()
  - 当调用函数时，函数中封装的代码会按照顺序执行

- 使用函数声明来创建一个函数

  - 语法：

    ​	function 函数名（[形参1,形参2,...,形参N]）{

    ​			语句

    }

- 使用函数表达式来创建一个函数

  - 语法：

    var 函数名 = function([形参1，形参2]){

    ​	语句；

    }；

  - 使用赋值语句，所以结尾注意加;分号

- 有参函数

  - 可以在函数()中来指定一个或多个形参(形式参数)
    - 多个形参之间使用,隔开，生命形参就相当于在函数内部声明了对应的变量
    - 但注意并不赋值

  - 在调用函数时，可以在()中指定实参(实际参数)
    - 实参回赋值给函数中对应的形参
  - 调用函数时，解析器不会检查实参的类型
    - 所以要注意，是都有可能接收到非法的参数，如果有可能则需要对参数进行类型的检查
  - 调用函数时，解析器也不会检查实参的数量
    - 多余的实参不会被赋值
    - 如果实参数量少于形参数量，则没有对应实参的形参将是undefined
  - 函数的实参可以是任意的数据类型

- 函数的返回值

  - return 关键字
  - 如果return 语句后不跟任何值就像与返回一个undefined
  - 如果函数中不写返回值return，也会返回undefined
  - return后可以跟任意类型的值

- 实参可以是任意的数据类型，也可以是一个对象

  - 当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递

- 函数也可以作为一个实参的一个参数

### 6. 方法

- 函数也可以称为对象的属性
  - 如果一个函数作为一个对象的属性保存，那么我们称这个函数是对象的方法
  - 调用这个函数就说调用对象的方法(method)
- 但是他只是名称上的区别没有其他的区别

#### 6.1 for...in 枚举对象中的属性

- 语法： for(var 变量 in 对象){

  }

- for in 语句 对象中有几个属性，循环体就会执行几次

- 每次执行完，会将对象中的一个属性名字赋值给变量

#### 6.2 toString()

- 当我们直接在页面中打印一个对象时，事实上是输出对象的toString()方法的返回值

### 7. 构造函数

- 构造函数就是一个普通的函数，创建方式和普通函数没有区别
  - 构造函数习惯上首字母大写
- 构造函数和普通函数的区别就是调用方式的不同
  - 普通函数是直接调用，而构造函数需要使用new关键字来调用
- 构造函数的执行流程
  - 立刻创建一个新的对象（堆内存）
  - 将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
  - 逐行执行函数中的的代码
  - 将新建的对象作为返回值返回
- 使用同一个构造函数创建的对象，我们称之为一类对象，也将一个构造函数称为一个类
  - 我们将通过一个构造函数创建的对象，称为是该类的实例
- instanceof 可以检查一个对象是否是一个类的实例
  - 语法： 对象 instanceof 构造函数
  - 所有的对象都是object的后代

### 8. 原型prototype

- 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
  - 这个属性对应着一个对象，这个对象就是我们所谓的原型对象
- 如果函数作为普通函数调用时，prototype没有任何作用
- 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向构造函数的原型对象
  - 我们可以通过 \__proto__ 来访问该属性
  - 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用
- 解决一些函数污染全局的问题
- 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有也会返回true
  - 可以用对象的 hasOwnProperty() 来检查对象自身中是否含有该属性
  - object对象的原型没有原型，如果在object中依然没有找到，则返回undefined

### 9. 垃圾回收（GC）

- 就像人们生活时间长产生垃圾一样，程序运行过程中也会产生垃圾
  - 这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收机制，来处理程序运行过程中产生的垃圾
- 当一个对象没有任何的变量或者属性对它进行引用，此时我们将永远无法操作该对象，此时这种现象就是一个垃圾
  - 这种现象会占据大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。
- 在js中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要进行垃圾回收操作
- 我们需要做的就只是要将不再使用的对象设置位null即可

## 五、 作用域

作用域指一个变量的作用范围

### 1. 全局作用域

- 直接编写在script标签中的js代码，都在全局作用域

- 全局作用域在页面打开时创建，在页面关闭时销毁

- 在全局作用域中有一个全局对象window，代表的是浏览器的一个窗口，由浏览器创建我们可以直接使用，我们可以直接使用

- 在全局作用域中

  - 闯将的变量都会作为window对象的属性保存

- 变量的声名提前

  - 使用var关键字声明的变量，会在所有的代码执行之前被声明，但是如果声明变量时不使用var关键字，则变量不会被声明提前

- 函数的生命提前

  - 使用函数声明形式创建的函数function() 函数{}，它会在所有的代码执行前就被创建 

  使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

- 全局作用域中的变量叫做全局变量，在页面中的任意位置都可以访问到

### 2. 函数作用域

- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
- 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
- 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量
- 当在函数作用域中操作一个变量时，它会在自身作用域中寻找，如果有就直接使用，如果没有就向上一级作用域中寻找
  - 在函数作用域也有声明提前的特性
  - 使用var关键字声明的变量，会在函数中所有的嗲马执行之前被声明
- 在函数中，不适用var声明的变量都会变成全局变量  

#### 2.1 this

- 解析器在调用函数每次都会想函数内部传递一个隐含的参数，这个隐含的参数就是this
- this指向的是一个对象，这个对象我们称为函数执行的**上下文对象**
- 根据函数的**调用方式**不同，this会指向不同的对象
  - 以函数的形式调用时，this永远都是window
  - 以方法的形式调用时，this就是调用方法的那个对象
- 总结
  - 当以函数的形式调用时，this是window
  - 当以方法的形式调用时，谁调用方法谁就是this
  - 当以构造函数的形式调用时，this就是新创建的那个对象

## 六、内建对象

### 1. 数组（Array）

- 数组是一个对象
- 数组时使用数字来作为索引操作元素
- 索引
  - 从0开始的整数就是索引
- 数组的存储性能比普通对象要好，所以开发中我们经常使用数组来存储一些数据
- typeof检查一个数组时，会返回object
- 向数组中添加元素
  - 语法： 数组[索引] = 值
- 读取
- 数组中的元素可以是任意的数据类型
  - 也可以是对象
  - 也可以是一个函数
  - 也可以放数组，我们称之为二维数组

#### 1.1 数组的方法

- push()
  - 该方法可以向数组的末尾添加一个或多个元素，并返回数组的长度
  - 可以将要添加的元素作为方法的参数传递
    - 这样这些元素将会自动添加到数组的末尾
  - 该方法会将数组新的长度作为返回值返回
- pop()
  - 该方法可以删除数组中的最后一个元素，并将被删除的元素作为返回值返回
- unshift()
  - 向数组开头添加一个或多个元素，并返回新的数组长度
  - 向前边插入元素以后，其他的元素索引会依次调整
- shift()
  - 可以删除数组的第一个元素，并将被删除的元素作为返回值返回
- slice()
  - 可以从已有的数组中返回选定的元素
  - 参数
    - 截取开始的位置的索引，包含开始索引
    - 截取结束的位置的索引，不包含结束索引
  - 该方法不会改变元素数组，而是将截取的元素封装到一个新数组中返回
  - 索引也可以传递一个负值，如果传递一个负值，则从后往前计算
- splice()
  - 可以用于删除数组中的指定元素
  - 使用splice()会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回
  - 参数：
    - 第一个：表示开始位置的索引
    - 第二个：表示删除的数量
    - 第三个及以后：可以传递一些新的元素，这些元素将会自动插入到开始位置索引的前边
- concat()
  - 可以连接两个或多个数组，并将新的数组返回
  - 该方法不会影响原数组
- join()
  - 该方法可以将数组转换为一个字符串
  - 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回
  - 在join()中可以指定一个字符串作为参数，这个字符串会成为数组中元素的连接符
    - 如果不指定连接符，则默认使用逗号
- reverse()
  - 该方法用来反转数组
  - 该方法会直接修改原数组
- sort()
  - 可以用来对数组中的元素进行排序
  - 会影响原数组，默认会按照Unicode编码进行排序
  - 数字也是按照Unicode编码来排序的，对数字进行排序时，可能会得到错误的结果
  - 可以自己指定排序规则
    - 我们可以在sort()中添加一个回调函数，来指定排序规则。
      - 回调函数中需要定义两个形参
      - 浏览器会分别使用数组中的元素座位上实参去 调用回调函数
    - 浏览器会根据回调函数的返回值来决定元素的顺序
      - 如果返回大于0的值，则元素会交换位置
      - 返回小于0的值，元素位置不变
      - 返回一个0，则认为两个个元素相当，也不交换位置

#### 1.2 遍历数组

一般都是用for循环去遍历数组，在js中为我们提供一个方法用来遍历数组

- forEach()
  - 这个方法只支持IE8以上的浏览器
  - forEach方法需要一个函数作为参数，像这种由我们创建但是不由我们调用的，我们称为回调函数
  - 数组中有几个元素函数就会执行几次，每次执行时，浏览器都会将遍历到的元素以实参传递进来，我们可以来定义形参，来读取这些内容
  - 浏览器会在回到函数中传递三个参数：
    - 第一个参数，就是当正在遍历的元素
    - 第二个参数，就是当前正在遍历的元素的索引
    - 第三个参数，就是正在遍历的数组

### 2. 函数的方法

#### 2.1 call()和apply()

- 这两个方法都是函数对象的方法，需要通过函数对象来调用
- 当对函数调用call()和apply()都会调用函数执行 
- 在调用call和apply时可以将一个对象指定为第一个参数
  - 此时这个对象将会成为函数执行时的this
- cal()方法可以将实参在对象之后依次传递
- apply()方法需要将实参封装到一个数组中统一传递

#### 2.2 arguments()

- 在调用函数时，浏览器每次都会传递进两个隐含的参数
  - 函数的上下文对象this
  - 封装实参的对象arguments
    - arguments是一个类数组对象（不是一个数组）
    - 可以通过索引来操作数据，也可以获取长度
    - 在调用函数时，所传递的实参都会在arguments中保存
    - arguments.length 可以用来获取实参的长度
    - 我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦
      - arguments[0] 表示是第一个实参
    - 他里边有一个属性叫做callee
      - 这个属性对应一个函数对象，就是当前正在指向的函数的对象

### 3. Date对象

在js中使用date对象来表示一个时间

- 如果直接使用构造函数创建一个date对象，则会封装为当前代码执行的时间
- 创建一个指定的时间对象
  - 需要在构造函数中传递一个表示时间的字符串作为参数
  - 日期的格式 月份/日/年 时:分:秒
- getDate()
- getDay()
  - 获取当前日期对象是周几
  - 会返回一个0-6的值
- getTime()
  - 获取当前日期对象的时间戳
  - 时间戳：指的是从格林威治标准时间的1970年1月1日，0时0分0秒 到当前日期所花费的毫秒数
  - 利用时间戳可以来测试代码的执行性能

- Math()
  - Math和其他对象的不同，他就是一个构造函数
    - 属于一个工具类创建对象，里边封装了数学运算相关的属性和方法
  - Math.random()
    - 可以用来生成一个0-1之间的随机数

### 4. 包装类

在js中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象

- String()
- Number()
- Boolean()

但是注意：在实际开发中我们不会使用基本数据类型，使用基本数据类型对象，再做一些比较的时候可能会带来一些不可预期的结果

- 方法和属性只能添加给对象，不能添加给基本数据类型
  - 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法
  - 调用完以后再将其转换为基本数据类型

### 5.字符串

- 在底层字符串是以字符数组的形式保存的

- charAt()

  - 返回字符串中指定位置的字符
  - 根据索引获取指定的字符

- charCodeAt()

  - 获取指定位置字符的字符编码（Unicode编码）

- concat()

  - 可以用来连接两个或多个字符串
  - 作用和+一样

- indexOf()

  - 检索一个字符串中是否含有指定内容
  - 如果字符串中含有该内容，则会返回第一个出现的索引
    - 躲过没有找到指定的内容，则会返回-1
  - 可以指定一个第二个参数，指定开始查找的位置

- split()

  - 可以将一个字符串拆分为一个数组

    - 参数：

      需要一个字符串作为参数，将会根据字符串去拆分数组

### 6.正则表达式

- 正则表达式用于定义一些字符串的规则
  - 计算机可以根据正则表达式来检查一个字符串是否符合规则
  - 获取将字符串中符合规则的内容并提取出来

- 创建正则表达式

  ```javascript
  var reg = new RegExp();
  ```

  语法：

  var 变量 = new RegExp("正则表达式","匹配模式")；

  - 匹配模式：
    - i
    - g

- 使用字面量来创建正则表达式
  - 语法： var 变量= /正则表达式/匹配模式
  - 使用字面量的方式创建更加简单
  - 使用构造函数创建更加灵活
- [] 里的内容也是或的关系
  - [ab ] == a|b
  - [a-z] 任意的小写字母
  - [^ ] 除了

- split()
  - 将一个字符串拆分成一个数组
  - 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串
- search()
  - 可以搜索字符串中是否含有指定内容
  - 可以接受正则表达式作为参数，然后会根据正则表达式去检索字符串
  - search()只会查找第一个，即使设置全局匹配也没有用
- match()
  - 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来
  - 默认情况下match只会找到第一个符合要求的内容，找到以后就停止检索，可以设置为全局匹配模式，就会匹配所有内容
  - 可以为一个正则表达式可以设置多个匹配模式，且顺序无所谓
  - match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果也会保存到数组中
- replace()
  - 可以将字符串中指定的内容替换为新的内容
  - 参数：
    - 被替换的内容，可以接受一个正则表达式作为参数
    - 新的内容
  - 默认只会替换第一个
- 量词
  - 通过量词可以设置一个内容出现的次数
  - 量词只对它前边的一个内容起作用
  - {n} 正好出现n次
  - {m,n} 出现m~n次
  - {m, } 出现m次以上

- 检查一个字符串是否已a开头
  - ^ 表示开头
  - $ 表示结尾

## 七、DOM

Domcument Object Model 文档对象模型

- 文档：文档表示的就是整个HTML网页文档
- 对象：对象表示将网页中的每一个部分都转换为一个对象
- 模型：使用模型来表示对象之间的关系，这样方便我们获取对象

### 7.1  节点

- node——构成HTML文档最基本的单元
- 常用节点分为四类：
  - 文档节点：整个HTML文档
  - 元素节点：HTML文档中的HTML标签
  - 属性节点：元素的属性
  - 文本节点：HTML标签中的文本内容

- 浏览器已经为我们提供文档节点对象，这个对象是window属性

  - 可以在页面中直接使用，文档节点代表的就是整个网页

  - document

    ```javascript
    var btn = document.getElementById("btn");
    //修改按钮的文字
    btn.innerHTML = "I'm Button";
    ```

### 7.2 事件

- 事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间
  - JavaScript与HTML之间的交互是通过事件来实现的
  - 我们可以在事件对应的属性中设置一些js代码，这样当事件被触发时，这些代码将会执行
    - 这种写法称为结构和行为耦合，不方便维护，不推荐使用
  - 可以为按钮的对应事件绑定处理函数的形式来影响事件
    - 当时间被触发时，其对应的函数将会被调用
  
- 文档的加载
  - 浏览器在加载页面时，是按照自上向下的顺序加载的
  - onload事件会在整个页面加载完成之后才触发
    - 为window绑定一个onload事件
      - 该事件对应的响应函数将会在页面加载完成之后执行
      - 这样可以确保我们的代码执行时所有的dom对象已经加载完毕了

- DOM查询

  通过document对象调用

  - getElementById()

    - 通过id属性获取一个元素节点对象
    - innerHTML 通过这个属性可以获取元素内部的html代码
      - 对于自结束标签，这个属性是没有意义的

  - getElementByTagName()

    - 可以根据标签名来获取一组元素节点对象

    - 这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中 

    - 如果需要读取元素节点属性

      - 直接使用  元素.属性名

      - 注意：class属性不能采用这种方式

        读取class属性时需要使用  元素.className

  - getElementByName()

    - 通过name属性获取一组元素节点对象
    
  - childNodes 属性

    - 会获取包括文本节点在内的所有节点
    - 根据dom标签标签间空白也会被当成是节点
      - 注意：在ie8及以下中的浏览器中不会将空白文档当成子节点

  - children属性

    - 可以获取当前元素的所有子元素

  - firstChild

    - 获取当前元素的第一个节点（包括空白文本节点）

  - firstElementChild

    - 获取当前元素的第一个子元素
    - 兼容性不好。不支持ie8及以下浏览器

  -  innerText()

    - 该属性获取到元素内部的文本内容
    - 他和innerHTML类似，不同的是他会自动将html去除

  - parentNode()

    - 属性，表示当前节点的父节点

  - previousSlibling

    - 属性，表示当前节点的前一个兄弟节点

  - nextSlibling

    - 属性，表示当前节点的后一个兄弟节点
  
- 事件对象

  - 当时间的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递传递进响应函数
  - 在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标，键盘的按键，鼠标滚轮的方向等
  
- 事件的冒泡

  - 所谓的冒泡（bubble）就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同时间也将会被触发
  - 在开发中大部分情况冒泡都是有用的，但是如果不希望事件冒泡，可以通过时间对象来取消冒泡

- 事件的委派

  - 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件

  - 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能

  - target

    - event中的target表示的出发事件的对象

    ```javascript
    event.target.className == "link";
    ```

- 事件的绑定

  - 使用 对象.属性 = 函数 的形式 绑定响应函数，不能绑定多个，如果绑定多个后边会覆盖前边的

  - addEventListener()

    - 通过这个方法也可以为元素绑定响应函数

    - 参数：

      - 1、事件的字符串，不要on
      - 2、回调函数，当事件触发时该函数会被调用
      - 3、是否在捕获阶段触发事件，需要一个布尔值，一般都传false 

      ```javascript
      btn.addEventListener("click",function(){
      	alert();
      },flase);
      ```

      

    - 使用addEventListener() 可以同时为一个元素的相同事件同时绑定多个响应函数。这样当事件被触发时，响应函数将会按照函数的绑定顺序执行

    - 这个方法不支持ie8及以下浏览器

  - attachEvent()

    - 在ie8中可以使用attachEvent()来绑定事件

    - 参数：

      - 1、事件的字符串，要on
      - 2、回调函数

      ```javascript
      btn.attachEvent("onclick",function(){
          alert();
      });
      ```

    - 这个方法也可以同时为一个事件绑定多个处理函数，不同的是他是后绑定先执行，执行顺序和addEventListener()相反

  - 解决兼容性问题

    - 定义一个函数bind，用来为指定元素绑定响应函数

      - addEventListener() 中的this，是绑定事件的对象
      - attachEvent()中的this，是window
      - 需要统一两个方法this

    - bind函数 参数：

      - obj 要绑定事件的对象
      - eventStr 事件的字符串
      - callback 回调函数

      ```javascript
      function bind(obj, eventStr, callback){
          if(obj.addEventListener){
              obj.addEventListener(evenStr, callback, false);
          }else{
              obj.attachEvent("on"+eventStr,function(){
                  callback.call(obj);
              });
          }
      }
      ```

      call函数可以指定调用this

- 事件的传播

  - 关于事件的传播网景公司和微软公司有不同的理解
  - 微软公司认为时间应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行
  - 网景公司认为事件应该是由外向内传播，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后再向内传播给后代元素
  - w3c 综合了两个公司的方案，将时间传播分成了三个阶段
    - 1、捕获阶段
      - 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
    - 2、目标阶段
      - 事件捕获到目标元素，捕获结束开始在目标元素上触发事件
    - 3、冒泡阶段
      - 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件
    - 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true
      - 一般情况下我们不会希望在捕获阶段触发事件，所以一般这个参数都是false
  - ie8以下的浏览器没有捕获阶段

- 当我们拖拽一个网页中的内容时，浏览器将会默认去搜索引擎中搜索内容，此时会导致拖拽功能异常，这个是浏览器的默认行为，如果不希望发生这个默认行文，可以通过return false来取消

- setCapture() 

  - 只有ie支持，但是在火狐调用时不会报错，如果是chrome调用，会报错
  - 对相关的事件进行捕获
  - 当地啊哦哦用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自己身上

- 鼠标滚轮的事件

  - onmousewheel()

    - 会在滚伦滚动时触发，但是火狐不支持该属性

  - 在火狐中需要使用DOMMouseScroll 来帮顶滚动事件

    - 注意该事件需要通过addEventListener() 函数来绑定

  - event.wheelDelta

    - 判断鼠标滚轮滚动的方向
    - 向上滚 120，向下滚 -120
    - wheelDelta 这个值我们只看正负，不看大小
    - 但是不支持火狐浏览器

  - 火狐中使用event.detail 来获取滚动的方向

    - 向上滚 -3 ， 向下滚 3

  - 注意：

    - 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动

    - 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为

    - 使用addEventListener() 方法绑定响应函数，取消默认行为时不能使用return false

    - 需要使用event来取消默认行为

      event.preventDefault();

      - 但是ie8不支持event.preventDefault() ，如是直接使用会报错，所以需要进行判断

      ```javascript
      event.preventDefault && event.preventDefault();
      ```

- 键盘事件

  - onkeydown

    - 按键被按下

    - 对于onkeydown来说如果一直按着某个案件不松手，则事件会一直触发

    - 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常快

      这种设计是为了防止误操作的发生

  - onkeyup

    - 按键被松开

  - 键盘事件一般都会绑定给一些可以获得焦点的对象，或者是document

  - 通过keyCode来获取按键的编码

  - 除了keyCode，事件对象中还提供了几个属性

    - altKey
    - ctrlKey
    - shiftKey
      - 这三个用来判断alt ctrl 和shift 是否被按下
      - 按下就返回true，否则就返回false

  - 在文本框中输入内容，属于onkeydown的默认行为

    - 如果在onkeydown中取消了默认行为，则输入的内容不会出现在文本框中
    - return false


### 7.3 获取和设置属性

- getAttribute
  - 是一个函数，只有一个参数——查询的属性的名字
  - 不属于document对象，不能通过document对象调用，只能通过元素节点对象调用，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行
  
- setAttribute
  
  - 对属性节点的值作出修改，与getAttribute一样，也是只能用于元素节点
  
- 注意：
  - setAttribute对文档作出修改后，再通过浏览器view source查看源代码，查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反应在文档本身的源代码里。
  - 这种现象源自DOM的工作模式：先加载文档的静态内容，再动态刷新不影响文档的静态内容
  - 对页面内容进行刷新却不需要在浏览器里刷新页面
  
- this
  
  - 在时间的响应函数中，响应函数是给谁绑定的this就是指谁
  
- body

  - 在document中有一个属性body，它保存的是body的引用

    ```javascript
    var body = document.body;
    ```

- documentElement

  - document.documentElement 保存的是html根标签

- document.all

  - 代表页面中的所有元素

- getElementByClassName() 

  - 根据元素class属性查询一组元素节点对象
  - 但是该方法不支持ie8及以下的浏览器

- querySelector()

  - 需要一个选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象
  - 虽然ie8中没有getElementByClassName() 但是可以利用querySelector()查询
  - 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个

- querySelectorAll()

  - 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回
  - 即使符合条件的元素只有一个，也会返回一个数组

### 7.4 dom的增删改

- createElement()
  - 创建一个元素节点对象
  - 需要一个标签名作为参数，将会根据该标签名创建元素节点对象
  - 将创建好的对象作为函数值返回
- createTextNode()
  - 可以用来创建一个文本节点对象
  - 需要一个文本内容作为参数，将会根据内容创建文本节点，并将新的节点返回
- appendChild()
  - 向一个父节点中添加新的子节点
  - 用法： 父节点.appendChild(子节点)
- insertBefore()
  - 可以在指定的子节点前插入新的子节点
  - 语法： 父节点.insertBefore(新节点，旧节点)
- 使用innerHTML也可以完成dom的增删改的操作
  - 更改的内容过多，可能会影响绑定响应函数
  - 一般我们会用两种方式结合使用
- confirm()
  - 用于弹出一个带有确认和取消按钮的提示框
  - 需要一个字符串作为参数，该字符串将会作为提示文字显示出来
  - 点击确定则返回true 点击取消则返回false
- 超链接跳转的默认行为
  - 点击超链接以后，超链接会跳转页面，这个超链接的默认行为
  - 我们不希望出现此默认行为，可以通过在响应函数的最后return false来取消默认行为
- 超链接的索引问题
  - for循环会在页面加载完成之后立即执行
  - 而响应函数会在超链接被点击时才会执行
  - 当响应函数执行时，for循环早已执行完毕

### 7.5 操作内联样式

- 通过js修改元素的样式

  - 语法： 元素.style.样式名=样式值

  - 样式值要是一个字符串

  - 注意：如果css的样式名中含有-，这种名称在js中是不合法的，例如background-color

    需要将这种样式名修改为驼峰命名法

  - 通过style属性设置的样式都是内联样式

    - 而内联样式有较高的优先级，所以通过js修改的样式往往会立即显示
    - 但是如果在样式中，写了一个 !important ，则此时样式会有最高的优先级，即使通过js也不能覆盖该样式，此时将会导致js修改样式失效，所以尽量不要使用 !important
    - 局限：style只能读取内联样式

- 获取元素的当前显示的样式

  - 语法： 元素.currentStyle.样式名
  - 可以用来读取当前元素正在显示的样式（样式表和内联样式谁当前生效就获取谁）
  - 缺陷：只有ie支持

- getComputedStyle() 

  - 获取元素当前的样式

  - 这个方法是window的方法，可以直接使用

  - 需要两个参数

    - 第一个：要获取样式的元素

    - 第二个：可以传递一个伪元素，一般都是null】

    - 刚方法会返回一个对象，对象中封装了当前元素对应的样式

      可以通过对象.样式名来读取样式

      如果获取的样式没有设置，则会获取到真实的值，而不是默认值

      比如：没有设置width，他不会获取到auto，而是一个长度

  - 不支持ie8及以下浏览器

  - 通过currentStyle和getComputedStyle()读取到的样式都是只读的

    不能修改，如果要修改必须要通过style属性
    
  - getStyle()方法解决以上不兼容问题

    ```javascript
    function getStyle(obj,name){
        if(window.getComputedStyle){
            return getComputedStyle(obj,null)[name];
        }else{
            return obj.currentStyle[name];
        }
    }
    ```

    ```javascript
    function getStyle(obj,name){
        return window.getComputedStyle?getComputedStyle(obj,null)[name]:obj.currentStyle[name];
    }
    ```

### 7.6 其他样式相关的属性

- clientWidth

  clientHeight

  - 这两个属性可以获取元素的可见宽度和高度

  - 这些属性都是不带px的，返回都是一个数字，可以直接进行计算
  - 会获取元素宽度和高度，包括内容去和内边距
  - 这些属性都是只读的，不能修改

- offsetWidth

  offsetHeight

  - 获取元素的整个宽度和高度，包括内容区和内边距、边框

- offsetParrent

  - 可以用来获取当前元素的定位父元素
  - 会获取到离当前元素最近的开启了定位的祖先元素
  - 如果所有的祖先元素都没有开启定位，则返回body

- offsetLeft

  - 当前元素相对与其定位父元素的水平偏移量

  offsetTop

  - 当前元素相对于其定位父元素的垂直偏移量

- scrollWeight

  scrollHeight

  - 可以获取元素整个滚动区域的高度和宽度

- scrollLeft

  scrollTop

  - 可以获取水平、垂直 滚动条滚动的距离

- onscroll
  
  - 该事件会在元素的滚动条滚动的时候触发

- clientX 

  clientY

  - 可以获取鼠标指针的坐标
  - 获取当前可见窗口的坐标

- pageX

  pageY

  - 可以获取鼠标当前页面的坐标
  - 注意：在ie8及以下不支持

- 在ie8中，响应函数被触发时，浏览器不会传递事件对象

  在ie8以以下的浏览器中，是将事件对象作为window对象的属性保存的

  - 处理事件对象兼容性问题：

    ```javascript
    if(!event){
        event = window.event;
    }
    ```

    ```javascript
    event = event || window.event;
    ```

- 获取滚动条滚动的距离

  - chrome认为浏览器的滚动条时body的，可以通过body.scrollTop来获取

  - 火狐等浏览器认为浏览器的滚动条时html的

  - 解决兼容性问题：

    ```javascript
    var st = document.body.scrollTop || document.documentElement.scrollTop;
    ```


## 八、BOM

- 浏览器对象模型

- BOM可以使我们通过js来操作浏览器

- 在BOM中为我们提供一组对象，用来完成对浏览器的操作

- BOM对象

  - Window
    - 代表的使整个浏览器的窗口，同时window也是网页中的全局对象
  - Navigator
    - 代表当前浏览器的信息，通过该对象可以用来识别不同的浏览器
  - History
    - 代表当前浏览器的地址栏信息，通过location可以获取地址栏信息，或者操作浏览器跳转页面
  - Location
    - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
    - 因与隐私原因，该对象不能同时获取到具体的历史记录，只能操作浏览器向前或者向后翻页
    - 改操作只能在档次访问时有效

  - Screen
    - 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关信息

- 这些BOM对象在浏览器中都是作为window对象的属性保存的

  - 可以tongguowindow对象来调用 ，也可以直接使用

### 8.1 Navigator

- 代表当前浏览器的信息，通过该对象可以用来识别不同的浏览器

- 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了

- 一般我们只会使用userAgent来判断浏览器的信息

  - userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容
  - 不同的浏览器会有不同的userAgent

- 在ie11中已经将微软和ie相关的标识都去除了，所以我们已经不能通过userAgent来识别一个浏览器是不是ie浏览器了

- 如果通过userAgent不能判断，还可以通过浏览器中特有的对象，来判断浏览器的信息

  - 比如：ActiveXObject

  ```javascript
  if("ActiveXObject" in window){
  	alert("是IE浏览器")
  }
  ```

### 8.2 History

- 代表当前浏览器的地址栏信息，通过location可以获取地址栏信息，或者操作浏览器跳转页面
- length
  - 属性，可以获取到当此当前访问的链接数量
- back()
  - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样
- forward()
  - 可以跳转下一个页面，作用和浏览器的前进按钮一样
- go()
  - 可以用来跳转到指定的页面
  - 他需要一个整数作为参数
    - 1：表示向前跳转一个页面
    - 2：向前跳转两个页面
    - -1：向后跳转一个页面

### 8.3 Location

- 代表当前浏览器的地址栏信息，通过location可以获取地址栏信息，或者操作浏览器跳转页面
- 直接打印location，可以获取到地址栏的信息（当前页面的完整路径）
- 如果直接将location属性修改为一个完整的路径，或相对路径
  - 我们页面会自动跳转到该路径，并且会生成相应的历史记录
- assign()
  - 用来跳转到其他的页面，作用和直接修改location一样
- reload()
  - 用于重新加载当前页面，等同于刷新按钮
  - 如果方法中传递true 作为参数，则会强制清空缓存刷新
- replace()
  - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
  - 注意：不会生成历史记录，不能使用回退按钮回退

### 8.4 定时器

- js程序的执行是十分快速的，如果希望程序每间隔一段时间执行一次，可以使用定时调用
- setInterval()
  - 定时调用
  - 可以将一个函数，每隔一段时间执行一次
  - 参数：
    - 回调函数，该函数会每隔一段时间被调用一次
    - 每次调用间隔的事件，单位是毫秒
  - 返回值：
    - 返回一个Number类型的数据
    - 这个数字用来作为定时器的唯一标识
- clearInterval()
  - 可以用来关闭一个定时器
  - 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
  - 可以接受任意参数
    - 如果参数是一个有效的定时器表示，则停止对应的定时器
    - 如果参数不是一个有效的标识，则什么也不做
    - 点击多次定时器按钮就会开启多个定时器，导致切换速度过快，并且我们只能关闭最后一次定时器
    - 所以在开启定时器之前我们需要关闭当前元素上的其它定时器

### 8.4 延时调用

- 延时调用一个函数不马上执行，而是隔一段时间以后再执行
- 而且只会执行一次
  - 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
  - 延时调用和定时调用实际上是可以相互代替的，在开发中可以根据自己需要来选择
- clearTimeout()
  - 来关闭一个延时调用

### 8.5class的操作

- 通过style属性来修改元素的样式，没修改一个样式，浏览器就需要重新渲染一次页面，这样的执行性能是比较差的，而且这种形式当我们要修改多个样式时，也不方便
- 我们可以通过修改元素的class属性来间接的修改样式，这样一来我们只需要修改一次，即可同时修改多个样式，浏览器只需要渲染页面一次，性能比较好
  - 并且这种方式使表型和行为进一步分离，操作方便

## 九、JSON

### 9.1 JSON简介

- JS中的对象只有js自己认识，其他语言都不认识
- json就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象
- json在开发中主要是用来数据的交互

- JSON

  - javaScript object notation —— js对象表示法
  - json和js对象的格式一样，只不过json字符串中的属性名必须加双引号，其他和js语法一致
  - 属性名要加双引号

- json分类：

  - 1、对象{}

  ```javascript
  var obj = '{"name":"张三","age":18,"gender":"男"}';
  ```

  - 2、数组[]

  ```javascript
  var arr = '[1,2,3,"hello",true]';
  ```

- json中允许的值：

  - 1、字符串
  - 2、数值
  - 3、布尔值
  - 4、null
  - 5、对象
  - 6、数组

### 9.2 JSON字符串转换为JS中的对象

- 在JS中，为我们提供了一个工具类，就叫JSON
- 这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON
- JSON.parse()
  - 可以将一个JSON字符串转换为js对象
  - 需要一个JSON字符串作为参数，会将该字符串转换为JS对象
- JSON.stringify()
  - 可以将一个js对象转换为JSON字符串
  - 需要一个js对象作为参数，会返回一个JSON字符串
- JSON这个对象在IE7及以下浏览器中不支持，所以这些浏览器调用时会报错

### 9.3 eval()函数

- 这个函数可以用来执行一段字符串形式的js代码，并将执行结果返回

- 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块

- 如果不希望将其当成代码块解析，则需要在字符串前后各加一个()

  ```javascript
  eval("(" + str +")");
  ```

- 注意：

  - 这个函数功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用
  - 执行性能比较差，执行速度很慢
  - 具有安全隐患

- 如果需要兼容IE7及以下的JSON操作，则可以通过引入一个外部的js文件来处理

# JsAdvance

## 一、数据类型

### 1.1 分类

- 基本类型
  - String
    - 任意字符串
  - Number
    - 任意的数字
  - boolean
    - true/false
  - undefined
  - null
- 对象(引用)类型
  - Object
    - 任意对象——存储数据
  - Function
    - 一种特别的对象(可以执行)
  - Array
    - 一特别的对象(数值下标，内部数据是有序的)

### 1.2 判断

- typeof
  - 可以判断：undefined / 数值 / 布尔值 / 字符串
  - 不能判断：null 与 object    object与array**（注意）**
- instanceof
  - 判断对象的**具体类型**
- === 
  - ==  会做数据转换
  - === 不会做数据转换，判断两个数据是否完全相等
  - 可以判断： undefined / null

### 1.3 实例

- 实例：实例对象

  ```javascript
  function Person(name,age){
  	this.name = name;
  	this.age = age;
  }
  ```

- 类型：类型对象

  ```javascript
  var p = new Person();//根据类型创建的实例对象
  ```

### 1.4 相关问题

- undefined 和 null 的区别？
  - undefined 代表定义未赋值
  - null 定义并赋值了，只是值为null
- 什么时候变量赋值为null？
  - 初始赋值，表明将要赋值为对象
  - 结束前，让b对象成为垃圾对象（被垃圾回收期回收）
- 严格区别变量类型和数据类型？
  - 数据的类型
    - 基本类型
    - 对象类型
  - 变量的类型(变量内存值的类型)
    - 基本类型：保存的就是基本类型的数据
    - 引用类型：保存的是地址值

## 二、数据、变量、内存

### 2.1 什么是数据？

- 存储在内存中代表特定信息的东西，本质上是010101
- 数据的特点：可传递，可运算
- 一切皆数据
- 内存中所有操作的目标：数据
  - 算术运算
  - 逻辑运算
  - 赋值
  - 运行函数

### 2.2 什么是内存？

- 内存条通电后产生的可存储数据的空间(临时的)
- 内存产生和死亡：内存条(电路板)==> 通电 ==> 产生内存空间 ==> 存储数据 ==> 处理数据 ==>断电 ==> 内存空间和数据都消失

- 内存中内容有两种数据
  - 内部存储的数据(基本数据)
  - 地址值数据
- 将一个对象赋值的时候才会读取地址值，其余情况都是读取的内容(内容之间的拷贝)
- 内存的分类
  - 栈：全局变量/局部变量
  - 堆：对象

### 2.3 什么是变量

- 可变化的量，由变量名和变量值组成
- 每个变量都对应的一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据

### 2.4 三者之间的关系

- 内存用来存储数据的空间 
- 变量是内存的标识

### 2.5 相关问题

- 在js中调用函数时传递变量参数时，是值传递还是引用传递？
  - 理解1：都是值(基本/地址值)传递
  - 丽姐2：可能是值传递，也可能时引用传递(地址值)
- js引擎如何管理内存？
  - 内存生命周期
    - 分配小内存空间，得到使用权
    - 存储数据，可以反复进行操作
    - 释放小内存空间
  - 释放内存
    - 局部变量：函数执行完自动释放
    - 对象：成为垃圾对象==>垃圾回收器回收

## 三、对象

### 3.1 什么是对象

- 多个数据的封装替
- 用来保存多个数据的容器
- 一个对象代表现实世界中的一个事物

### 3.2 为什么要用对象

- 统一管理多个数据

### 3.3 对象的组成

- 属性：属性名(字符串)和属性值(任意)组成
- 方法：一种特别的属性

### 3.4 如何访问对象内部数据

- .属性名：编码简单，有时不能用

- ['属性名']：编码麻烦，能通用

  - 属性名包含特殊字符：-  空格 

  - 变量名不确定

    ```javascript
    var propName = 'myAge';
    var value = 19;
    //p.propName = value; 不能用
    p[propName] = value;
    console.log(p[propName]);
    ```

## 四、函数

### 4.1 什么是函数?

- 实现特定功能的n条语句的封装体
- 只有函数是可以执行的，其它类型的数据是不能执行的

### 4.2 为什么要用函数？

- 提高代码复用
- 便于阅读交流

### 4.3如何定义函数

- 函数声明
- 表达式

### 4.4 如何调用(执行)函数？

- test()：直接调用
- obj.test()：通过对象调用
- new test()：new调用
- test.call/apply(obj)：临时让test称为obj的方法进行调用
  - 可以让一个函数称为指定任意对象的方法进行调用

### 4.5 回调函数

- 什么函数是回调函数？

  - 你定义的
  - 你没有调用
  - 但最终它执行了

- 常见的回调函数

  - dom事件回调函数
  - 定时器回调函数

  - ajax请求回调函数
  - 生命周期回调函数

### 4.6 IIFE

- 理解

IIFE-Immediate-Invoked Function Expression 立即执行(调用)函数表达式

```javascript
(function () {//匿名函数自调用
    console.log('...')
})()
```

- 作用
  - 隐藏实现
  - 不会污染外部（全局）命名空间
  - 用来编写js模块

### 4.7 this

- this是什么？
  - 任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window
  - 所有函数内部都有一个变量this
  - 它的值是调用函数的当前对象
- 如何确定this值
  - test()：window
  - p.test()：p
  - new test()：新创建的对象
  - p.call(obj)：obj

### 4.8js语句分号的问题

- js一条语句的后边可以不加分号
- 是否加分号是编码风格问题，没有应该不应该，只有自己喜欢不喜欢
- 以下两种情况不加分号会有问题：
  - 小括号开头的前一条语句
  - 中方括号开头的前一条语句
- 解决办法：在行首加分号
- 强有力的例子：vue.js库

## 五、原型prototype

### 5.1 函数的prototype属性

- 每个函数都有一个prototype属性，它默认指向一个object空对象（即称为：原型对象）
- 原型对象中有一个属性constructor，它指向函数对象

### 5.2 给原型对象添加属性（一般都是方法）

- 作用：函数的所有实例对象自动拥有原型中的属性（方法）

- 给原型对象添加属性(一般是方法) ==> 实例对象可以访问

### 5.3 显式原型与隐式原型

- 每个*函数function*都有一个prototype，即显式原型(属性)

- 每个*实例对象*都有一个\__proto__，可称为隐式原型(属性)

- **实例对象的隐式原型的值等于其对应构造函数的显示原型的值**

  ```javascript
  function Fn(){}
  var fn = new Fn()
  Fn.prototype===fn.__proto__
  ```

- 内存结构

  <img src="C:\Users\Tan\AppData\Roaming\Typora\typora-user-images\image-20210201205630220.png" alt="image-20210201205630220" style="zoom: 50%;" />

- 总结：
  - 函数的prototype属性：在定义函数时自动添加的，默认值是一个空object对象
  - 对象的\__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值
  - 程序员能直接操作显示原型，但不能直接操作隐式原型(ES6之前)

### 5.4 原型链

- 图解

  ```javascript
  function Fn(){
  	this.test1 = function(){
          console.log('test1()')
      }
  }
  Fn.prototype.test2 = function(){
      console.log('test2()')
  }
  var fn = new Fn()
  fn.test1()
  fn.test2()
  console.log(fn.toString())
  fn.test3()
  ```

  <img src="C:\Users\Tan\AppData\Roaming\Typora\typora-user-images\image-20210202112112966.png" alt="image-20210202112112966" style="zoom:50%;" />

- 访问一个对象的属性时，
  - 现在自身属性中查找，找到返回
  - 如果没有，再沿着\__protot__这条链向上查找，找到返回
  - 如果最终没有找到，返回undefined
- 别名：隐式原型两（本质）
- 作用：查找对象的属性（方法）

### 5.5构造函数、原型、实体对象的关系

- 关系1

```javascript
var o1 = new Object()
var o2 = {}
```

<img src="C:\Users\Tan\AppData\Roaming\Typora\typora-user-images\image-20210202142130690.png" alt="image-20210202142130690" style="zoom: 33%;" />

- 关系2

```javascript
function Foo(){}
//var Foo = new Function()
//Functon = new Function()
```

**所有函数的\__proto__都是一样的**

<img src="C:\Users\Tan\AppData\Roaming\Typora\typora-user-images\image-20210202143000822.png" alt="image-20210202143000822" style="zoom: 50%;" />

- 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)

  ```javascript
  Fn.prototype instanceof Object//true
  Object.prototype instanceof Object//false
  Function.prototype instanceof Object//true
  ```

- 所有函数都是Function的实例，包括它本身

  - Function 是它自身的实例

  ```javascript
  Function.__proto__ === Function.prototype
  ```

- Object的原型对象是原型链的尽头

  ```javascript
  console.log(Object.prototype.__proto__)//null
  ```

### 5.6 属性问题

- 读取对象的属性值时：会自动到原型链中**查找**
- 设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值
- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上

### 5.7 探索instanceof

- instanceof 是如何判断的？

  - 表达式：A instanceof B
  - 如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false

- 案例1

  ```javascript
  function Foo(){}
  var f1 = new Foo();
  console.log(f1 instanceof Foo);
  console.log(f1 instanceof Object);
  ```

  <img src="C:\Users\Tan\AppData\Roaming\Typora\typora-user-images\image-20210202153255140.png" alt="image-20210202153255140" style="zoom:50%;" />

- 案例2

  ```javascript
  console.log(Object instanceof Function)//ture
  console.log(Object instanceof Object)//ture
  console.log(Function instanceof Function)//ture
  console.log(Function instanceof Object)//ture
  
  function Foo(){}
  console.log(Object instanceof Foo)//false
  ```

### 5.8变量提升与函数提升

- 变量声明提升
  - 通过var定义(声明)的变量，在定义语句之前就可以访问到
  - 值：undefined
- 函数声明提升
  - 通过function声明的函数，在之前就可以直接调用
  - 值：函数定义(对象)
- 注意：
  - 函数提升必须是函数声明形式定义的函数
  - 函数提升的优先级高于变量提升

## 六、执行上下文

### 6.1代码分类

- 全局代码
- 函数(局部)代码

### 6.2 全局执行上下文

- 在执行全局代码前将window确定为全局执行上下文
- 对全局数据进行预处理
  - var
  - 定义的全局变量 ==> undefined ，添加为window属性
  - function生命的全局函数 ==> 赋值（fun），添加为window的方法
  - this ==> 赋值（window）
- 开始执行全局代码

### 8.3 函数执行上下文

- 对局部数据进行预处理
  - 形参变量 ==> 赋值（实参）==> 添加为执行上下文的属性
  - argument ==> 赋值（实参列表），添加为执行上下文的属性
  - var定义的局部变量 ==> undefined，添加为执行上下文的属性
  - function声明的函数 ==> 赋值（fun）添加为执行上下文的方法
  - this ==> 赋值（调用函数的对象）
- 开始执行函数体代码

### 8.4 执行上下文栈

- 在全局代码执行前，js引擎就会创建一个栈来存储管理所有的执行上下文对象
- 在全局执行上下文（window）确定后，将其添加到栈中（压栈）
- 在函数执行上下文创建吼，将其添加到栈中（压栈）
- 在当前函数执行完后，将栈顶的对象移除（出战）
- 当所有的执行代码执行完毕后，栈中只剩下window

## 七、作用域

### 7.1 理解

- 就是一块”地盘“，一个代码段所在的区域
- 他就是静态的（相对于上下文对象），在编写代码时就确定了

### 7.2 分类

- 全局作用域
- 函数作用域
- 没有块作用域（es6就有了）

### 7.3 作用

隔离变量，不同作用域下同名变量不会有冲突

### 7.4 与执行上下文

- 区别1
  - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时
  - 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
  - 函数执行上下文是在调用函数时，函数体代码执行之前创建
- 区别2
  - 作用域是静态的，只要函数定义好了就一直存在，且不会再变化
  - 执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放
- 联系
  - 上下文环境（对象）是从属于所在的作用域
  - 全局上下文环境 ==> 全局作用域
  - 函数上下文环境 ==> 对应的函数使用域

### 7.5 作用域链

- 理解
  - 多个上下级关系的作用域形成的链，它的方向时自下向上的（从内到外）
  - 查找变量时就是沿着作用域链来查找的
- 查找一个变量的查找规则
  - 在当前作用域下的执行上下文中查找对应的属性，如果有就直接返回，否则进入2
  - 在上一级作用于的执行上下文中查找对应的属性，如果有直接返回，否则进入3
  - 再次执行2的相同操作，知道全局作用域，如果还找不到就抛出找不到的异常

## 八、闭包closure

### 8.1 循环遍历与监听

```javascript
for (var i = 0,length = btn.length; i < length; i++){
	(function(i){
        var btn = btns[i]
        btn.onclick = function () {
            alert('第' + (i+1) + '个')
        }
    })(i)
}
```

### 8.2 理解

- 如何产生闭包？
  - 当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包
    - 调用外部函数才会产生闭包

- 闭包到底是什么？
  - 使用chrome调试查看
  - 理解一：闭包就是嵌套的内部函数（绝大多数人）
  - 理解二：包含被引用变量（函数）的对象（少数人）
  - 注意：闭包存在于嵌套的内部函数中
- 产生必报的条件
  - 函数嵌套
  - **内部函数引用了外部函数的数据（变量/函数）**

### 8.3 常见的闭包

- 将函数作为另一个函数的返回值

  ```javascript
  function fn1(){
      var a = 2
      function fn2() {
          a++
          console.log(a)
      }
      return fn2
  }
  var f = fn1()
  f()//3
  f()//4
  ```

- 将函数作为实参传递给另一个函数调用

  ```javascript
  function showDelay(msg,time){
      setTimeout(function () {
          alert(msg)
      },time)
  }
  showDelay('hello',2000)
  ```

### 8.4 闭包的作用

- 使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
- 让函数外部可以操作（读写）到函数内部的数据（变量/函数）
- 问题：
  - 再执行完毕后，函数内部声明的局部变量是否还存在？
    - 一般是不存在的，存在于闭包中的变量才可能存在
  - 在函数外部能直接访问函数内部的局部变量吗？
    - 不能，但是我们可以通过闭包技术让外部操作它（将函数作为返回值返回）

### 8.5 闭包的生命周期

- 产生：在嵌套内部函数定义执行完时就产生了（不是在调用）
- 死亡：在嵌套的内部函数成为垃圾对象时

### 8.6 闭包的应用

- 自定义JS模块
  - 具有特定功能的js文件
  - 将所有的数据和功能都封装在一个函数内部(私有的)
  - 只向外暴露一个 包含n个方法的对象或函数
  - 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能

### 8.7 闭包的缺点

- 问题：
  - 函数执行后，函数内的局部变量没有释放，占用内存时间会变长
  - 容易造成内存泄露

- 解决：

  - 能不用闭包就不用

  - 及时释放

    ```javascript
    f = null
    //让内部函数成为垃圾对象 ==> 回收闭包
    ```

### 8.8 内存溢出与泄露

- 内存溢出
  - 一种程序运行出现的错误
  - 当程序运行需要哦的内存超过了剩余的内存时，就抛出内存溢出的错误
- 内存泄漏
  - 占用的内存没有及时释放
  - 内存泄漏积累多了就容易导致内存溢出
  - 常见的内存泄漏：
    - 意外的全局变量
    - 没有及时清理的计时器或者回调函数
    - 闭包

## 九、面向对象高级

### 9.1 对象创建模式

- 方式一：Object构造函数模式

  - 套路：先创建空Object对象，再动态添加属性/方法 
  - 适用场景：起始时不确定对象内部数据
  - 问题：语句太多

  ```javascript
  var p = new Object()
  p.name = 'Tom'
  p.age = 18
  p.setName = function(name){
      this.name = name
  }
  
  //test
  p.setName('JACK')
  console.log(p.name,p.age)
  ```

- 方式二：对象字面量模式

  - 套路：使用{}创建对象，同时指定属性/方法
  - 适用场景：起始时对象内部数据是确定的
  - 问题：如果创建多个对象，会有重复代码

  ```javascript
  var p = {
      name:'tom',
      age:12,
      setName:function(name){
          this.name = name
      }
  }
  //test
  p.setName('JACK')
  console.log(p,name,p.age)
  ```

- 方式三：工厂模式

  - 套路：通过工厂函数动态创建对象并返回（返回一个对象的函数都可以称为工厂函数）
  - 适用场景：需要创建多个对象
  - 问题：对象没有一个具体的类型，都是Object类型

  ```javascript
  function createPerson(name,age){
  	var obj = {
          name : name,
          age:age,
          setName:function(name){
              this.name = name
          }
      }
      return obj
  }
  var p1 = createPerson('tom',18)
  ```

- 方式四：自定义构造函数模式

  - 套路：自定义构造函数，通过new创建对象
  - 适用场景：需要创建多个类型的对象
  - 问题：每个对象都有相同的数据，浪费内存

  ```javascript
  function Person(name,age){
      this.name = name
      this.age = age
      this.setName = function(name){
          this.name = name
      }
  }
  //test
  var p1 = new Person('tom',12)
  ```

- 方式五：构造函数 + 原型 的组合模式

  - 套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
  - 适用场景：需要创建多个类型确定的对象

  ```javascript
  function Person(name,age){
      this.name = name
      this.age = age
  }
  Person.prototype.setName = function(name){
      this.name = name
  }
  
  var p1 = new Person('tom',23)
  var p2 = new Person('jack',27)
  ```

### 9.2 继承

- 方式一：原型链继承
  - 套路
    - 定义父类型构造函数
    - 给父类型的原型添加方法
    - 定义子类型的构造函数
    - 创建父类型的对象赋值给子类型的原型
    - 将子类型原型的构造属性设置为子类型
    - 给子类型原型添加方法
    - 创建子类型的对象：可以调用父类型的方法
  - 关键
    - 子类型的原型为父类型的一个实例对象
    - 让子类型的原型constructor指向子类

- 方式二：借用构造函数继承(假继承)
  - 套路
    - 定义父类型构造函数
    - 定义子类型构造函数
    - 在子类型构造函数中调用父类型构造
  - 关键
    - 在子类型构造函数中通用call() 调用父类型构造函数

- 方式三：原型链+借用构造函数的组合继承
  - 利用原型链实现对父类型对象的方法继承
  - 利用super()借用父类型构建函数初始化相同属性

### 9.3 进程

- 线程
  - 是进程内的一个独立的执行单元
  - 是程序执行的一个完整流程
  - 是CPU的最小的调度单元
- 相关
  - 应用程序必须运行在某个进程的某个线程上
  - 一个进程中至少有一个运行的线程；主线程，进程启动后自动创建
  - 一个进程中也可以同时运行多个线程，我们会说程序时多线程执行的
  - 一个进程内的数据可以工期中的多个线程直接共享
  - 多个进程之间的数据是不能直接共享的
  - 线程池(thread pool)：保存多个线程对象的容器，实现线程对象的反复利用
- js是单线程执行的
  - 证明js执行是单线程的
    - setTimeout()的回调函数是在主线程执行的
    - 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
  - 为何js要用单线程模式，为不是多线程模式?
    - javaScript 的单线程，与他的用途有关
    - 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM
    - 这决定了它只能是单线程，否则会带来很复杂的同步问题
  - 代码分类
    - 初始化代码
    - 回调代码
  - js引擎执行代码的基本流程
    - 先执行初始化代码：包含一些特别的代码  	回调函数（异步执行）
      - 设置定时器
      - 绑定监听
      - 发送ajax请求
    - 后边某个时刻才会执行回调代码
- 浏览器
  - 内核由很多模块组成
    - js引擎模块：负责js程序的编译与运行
    - html/css 文档解析模块：负责页面文本的解析
    - dom/css 模块：负责dom/css在内存中的相关处理
    - 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）
    - 定时器模块：负责定时器的管理
    - 事件响应模块：负责时间的管理
    - 网络请求模块：负责ajax请求

### 9.4 定时器的思考

- 定时器是定时执行的吗？
  - 定时器并不能保证真正定时执行
  - 一般会延迟一点时间（可以接受），也有可能延迟很长时间（不能接受）
- 定时器回调函数是在分线程执行的吗？
  - 在*主线程* 执行的，js是单线程的
- 定时器是如何实现的？
  - 事件循环模型

### 9.5事件循环模型

- 所有代码分类

  - 初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码
  - 回调执行代码（异步代码）：处理回调逻辑

- js引擎执行代码的基本流程：

  - 初始化代码 ---> 回调代码

- 模型的2个重要组成部分：

  - 时间管理模块
  - 回调队列

- 模型的运转流程

  - 执行初始化代码，将事件回调函数交给对应模块管理
  - 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中
  - 只有当初始化代码执行完后（可能需要一定时间），才会便利读取回调队列中的回调函数执行

  <img src="D:\project_file\doc\eventLoop.png" alt="eventLoop" style="zoom:50%;" />

### 9.6 Web Workers

- H5规范提供了js分线程的实现，取名为：web Workers
- 相关api
  - Worker：构造函数，加载分线程执行的js文件
  - Worker.prototype.onmessage：用于接收另一个线程的回调函数
  - Worker.prototype.postMessage：向另一个线程先发消息
- 不足
  - worker内代码不能操作dom
  - 不能跨域加载js
  - 不是每个浏览器都支持这个新特性
- 介绍
  
  - web worker 是HTML5 提供的一个JavaScript多线程解决方案，我们可以将一些大计算量的代码交由web worker运行而不冻结用户界面，但是子线程完全受主线程控制，且不的操作dom，所以这个新标准并没有改变JavaScript单线程的本质。
  
  <img src="C:\Users\Tan\AppData\Roaming\Typora\typora-user-images\image-20210219125736363.png" alt="image-20210219125736363" style="zoom:50%;" />